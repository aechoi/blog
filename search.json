[
  {
    "objectID": "publications/publications.html",
    "href": "publications/publications.html",
    "title": "publications",
    "section": "",
    "text": "Dynamic decay compensation for first order high pass filters\n    A. Choi, J. Drewniak, P. Munger, A. Nonaka, A. Rahimi, M. Zimmer\n    U.S. Patent 12,353,500 B1\n    Jul 8, 2025\n    PDF\n  \n\n\n\n  \n  \n    Compressing load signal transmissions\n    S. Bhadsavle, A. Choi, G. Jordan, P. Munger, R. Riggs, B. Yee, M. Zimmer\n    U.S. Patent 11,940,320 B1\n    Mar 26, 2024\n    PDF\n  \n\n\n\n  \n  \n    Piezoelectric weight sensing apparatus\n    R. Riggs, A. Pierce, C. Volk, A. Choi, R. Ahud, G. Jordan, P. Munger, J. Drewniak\n    U.S. Patent 11,796,378 B1\n    Oct 24, 2023\n    PDF\n  \n\n\n\n  \n  \n    Determining inventory levels using switch-equipped strips and patterns of activated or deactivated indicators\n    M. DesJardien, K. Doe, D. Beltzer, A. Pierce, A. Choi, J. Drewniak, P. Munger, R. Riggs, S. Dholakia, M. Mosman, S. Phan Lung Li\n    U.S. Patent 11,410,122 B1\n    Aug 9, 2022\n    PDF\n  \n\nNo matching items"
  },
  {
    "objectID": "publications/publications.html#patents",
    "href": "publications/publications.html#patents",
    "title": "publications",
    "section": "",
    "text": "Dynamic decay compensation for first order high pass filters\n    A. Choi, J. Drewniak, P. Munger, A. Nonaka, A. Rahimi, M. Zimmer\n    U.S. Patent 12,353,500 B1\n    Jul 8, 2025\n    PDF\n  \n\n\n\n  \n  \n    Compressing load signal transmissions\n    S. Bhadsavle, A. Choi, G. Jordan, P. Munger, R. Riggs, B. Yee, M. Zimmer\n    U.S. Patent 11,940,320 B1\n    Mar 26, 2024\n    PDF\n  \n\n\n\n  \n  \n    Piezoelectric weight sensing apparatus\n    R. Riggs, A. Pierce, C. Volk, A. Choi, R. Ahud, G. Jordan, P. Munger, J. Drewniak\n    U.S. Patent 11,796,378 B1\n    Oct 24, 2023\n    PDF\n  \n\n\n\n  \n  \n    Determining inventory levels using switch-equipped strips and patterns of activated or deactivated indicators\n    M. DesJardien, K. Doe, D. Beltzer, A. Pierce, A. Choi, J. Drewniak, P. Munger, R. Riggs, S. Dholakia, M. Mosman, S. Phan Lung Li\n    U.S. Patent 11,410,122 B1\n    Aug 9, 2022\n    PDF\n  \n\nNo matching items"
  },
  {
    "objectID": "publications/publications.html#course-papers",
    "href": "publications/publications.html#course-papers",
    "title": "publications",
    "section": "course papers",
    "text": "course papers\n\n\n\n  \n  \n    LQR-Trees with Modified Distance Heuristics\n    A. Choi\n    Jun 13, 2025\n    PDF\n  \n\n\n\n  \n  \n    A Comparative Study of Autonomous Quadrotor Race Trajectory Generation Methods and Controllers\n    S. Akhetova, A. Choi, B. Sarigol\n    Jun 12, 2025\n    PDF\n  \n\nNo matching items"
  },
  {
    "objectID": "posts/recreational_math/head_related_tfs/head_related_tfs.html",
    "href": "posts/recreational_math/head_related_tfs/head_related_tfs.html",
    "title": "Generating 3D Audio with Head Related Transfer Functions (HRTFs)",
    "section": "",
    "text": "I made a script to make regular audio sound 3D\nBack around 2012 I saw this demo on YouTube about a “Virtual Barber Shop”. When listened to with headphones, the actors are able to move around the listener as if they were in the room with you.\nIt’s actually still up (at the time of writing). Worth a listen if you’ve never heard it before.\nHearing this for the first time was what I imagine it was like for people to see color movies and TV for the first time.\nMore recently (during Covid boredom) I wanted to look more deeply into how this sort of audio could be made and to see if there was a way to do it without buying expensive hardware.\nOften the explanation people give is that this is an example of “binaural audio” where microphones are placed inside a dummy head (like the one pictured below) so that the differences heard between the left and right ear are interpreted as directions.\nThis certainly plays a part but is not the whole story. The problem with that explanation is that it doesn’t explain why you can tell when a sound comes from above or below you. In those cases, the sounds entering your left and right ear could be the exact same yet you can still localize the sound in the correct direction. The same goes for when a sound is directly in front or behind you. Simply adding delay to one side or the other is not sufficient to encode all of the spatial data.\nThe frequency content of the sounds themselves are subject to different transfer functions that are a function of the relative position of the sound origin to your head, the shape and composition of your head, the shape of your ears, the room your in, and a variety of other factors.\nThese Head Related Transfer Functions (HRTFs) can be modeled and measured. In fact there is a convenient online database filled with many examples. Generally these transfer functions are stored as an array of pairs of impulse responses (one for each ear). Convolving these impulse responses with any audio file lets you make the audio sound like it’s coming from somewhere in space.\nThese impulse responses are generally collected over the surface of multiple spheres at many distances from the listener.\nBelow is an example implementation I made using Bernschütz (2013). The code can be found on my github page here.\nIn it, I use a method found in Gamper (2013) to search for and interpolate the HRIRs. The method involves triangulating (tetrating?) the space using Delaunay triangulation. Then, given some starting tetrahedron, determine which vertex is furthest from the desired point in space. The tetrahedron that shares the face opposite that vertex is then the next nearest of the neighboring tetrahedrons. This process is continued until the desired point lies within the current tetrahedron.\nOnce found, the HRIRs at the vertices of that tetrahedron can be interpolated together using barycentric interpolation, providing a smooth transition when the point moves across the space to other tetrahedrons. The audio can now be convolved with the appropriate HRIR.\nWhen I first worked on this project back in 2020, I just had a little GUI that the user could interact with (as seen in the video above). Later on, I wanted to make a more hands-free way to move the audio around that could be used when on a call, streaming, or recording video.\nI implemented some head tracking and mapped the location of the face in the frame to control the source location using OpenCV and MediaPipe. Below is a quick demo. The code can be found on my repo.\nUltimately I was hoping that I could prank some of my coworkers in our online meetings, but it turns out most VOIP software streams mono audio to save on network bandwidth."
  },
  {
    "objectID": "posts/recreational_math/head_related_tfs/head_related_tfs.html#references",
    "href": "posts/recreational_math/head_related_tfs/head_related_tfs.html#references",
    "title": "Generating 3D Audio with Head Related Transfer Functions (HRTFs)",
    "section": "1 References",
    "text": "1 References\n\nBernschütz, Benjamin. 2013. “A Spherical Far Field HRIR/HRTF Compilation of the Neumann KU 100.” In Proceedings of the AIA-DAGA Conference on Acoustics. Merano, Italy. http://audiogroup.web.th-koeln.de/FILES/AIA-DAGA2013_HRIRs.pdf.\n\n\nGamper, Hannes. 2013. “Head-Related Transfer Function Interpolation in Azimuth, Elevation, and Distance.” The Journal of the Acoustical Society of America 134 (6): 3761–72. https://doi.org/10.1121/1.4828983."
  },
  {
    "objectID": "posts/engineering/henry/henry.html",
    "href": "posts/engineering/henry/henry.html",
    "title": "Animatronic “Henry”",
    "section": "",
    "text": "I made a head tracked desktop animatronic.\nOn streaming sites like Twitch or YouTube, there has been an increasing number of “V-Tuber” [Virtual YouTuber] entertainers. These typically consist of a streamer controlling a virtual avatar via motion tracking. I wanted to take the same idea but control a physical avatar using a similar method.\nBelow is a demo of what I ended up with. His name is Henry.\n\nI started by defining some of the requirements including the types of motions I wanted Henry to be capable of. Looking side to side and up/down were needed, but roll isn’t a very natural thing for your neck to do. I also wanted a face that was expressive enough to convey some basic emotions while being simple enough to be controlled by an Arduino that I had lying around.\nI also needed the face to look fine on camera. LEDs behind a thin two layer 3D print provided a soft, diffuse light while providing a simple way to structurally hold the LEDs.\n\n\n\n\n\n\nA closeup of Henry’s face\n\n\n\n\n\n\n\nA closer up\n\n\n\n\n\nAfter experimenting a bit, I made the following CAD models in SolidWorks to begin printing of the parts (Ender 3).\n\n\n\n\n\n\n\n\n\n\n\n\n\nBefore soldering things together, I tested things by first jumpering all the connections to a breadboard. The circuitry is just hooking up some servos and LEDs, so there’s not much to it other than selecting some resistor values. I did end up using some logic level fets because I was running out of GPIO pins on the Arduino Uno.\n\n\n\n\n\n\n\n\n\n\nThe Arduino communicated over serial to a python script I had made which does a couple things.\n\nMeasure the RMS of my microphone\nTrack the pose of the user’s head and extract azimuth/elevation angles\nListen for keyboard commands that switched the facial expressions (couldn’t get emotion recognition working consistently enough)\n\nAfter validating that everything was working properly, I made two PCBs (using KiCad), one for Henry’s face and a shield for the Arduino that housed the electronics.\n\n\n\n\n\n\n\n\n\n\nSwapping these in significantly reduced the number of cables that needed to plug into Henry’s head, making his movements much faster and more natural.\n\n\n\n\n\n\n\n\n\n\nThe final and most difficult part of this project was to decide on whether his smile should be a full smile or a smirk. Honestly, I think the smirk looks better, but I’ve been told it makes it look like his face is just broken 🤷‍♂️.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEdit History\n\n\n\n\n2025-07-31: Reformatted for new site"
  },
  {
    "objectID": "demos.html",
    "href": "demos.html",
    "title": "demos",
    "section": "",
    "text": "This page lists any visualizations, interactive graphics, or teaching material I’ve made.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPhasors\n\n\n\nelectrodynamics\n\n\n\n\n\n\n\n\n\nAug 15, 2025\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "demos/phasors/phasors.html",
    "href": "demos/phasors/phasors.html",
    "title": "Phasors",
    "section": "",
    "text": "Phasors can feel a bit mystical. Many students may simply memorize the rules associated with them and run calculations without developing a more fundamental understanding. It’s not uncommon for this to be the case at both the undergraduate and graduate level.\nThe goal of this document is to motivate the use of phasors from the ground up, as well as to provide visual representations of complex numbers that make them intuitive to understand. Hopefully by the end, they seem like an obviously good choice for modeling sinusoidal signals.\nIf you’d like to skip to what I believe is the most illuminating section, check out Section 3.3.2. I’d also recommend pausing any animations you are done with as having too many running at once can cause the browser to slow down.\nMuch of the content of this document is based on the course notes for UW EEP 592 (Goldstein 2025a; and Goldstein 2025b)."
  },
  {
    "objectID": "demos/phasors/phasors.html#introduction",
    "href": "demos/phasors/phasors.html#introduction",
    "title": "Phasors",
    "section": "",
    "text": "Phasors can feel a bit mystical. Many students may simply memorize the rules associated with them and run calculations without developing a more fundamental understanding. It’s not uncommon for this to be the case at both the undergraduate and graduate level.\nThe goal of this document is to motivate the use of phasors from the ground up, as well as to provide visual representations of complex numbers that make them intuitive to understand. Hopefully by the end, they seem like an obviously good choice for modeling sinusoidal signals.\nIf you’d like to skip to what I believe is the most illuminating section, check out Section 3.3.2. I’d also recommend pausing any animations you are done with as having too many running at once can cause the browser to slow down.\nMuch of the content of this document is based on the course notes for UW EEP 592 (Goldstein 2025a; and Goldstein 2025b)."
  },
  {
    "objectID": "demos/phasors/phasors.html#preliminaries-complex-numbers-and-eulers-equation",
    "href": "demos/phasors/phasors.html#preliminaries-complex-numbers-and-eulers-equation",
    "title": "Phasors",
    "section": "2 Preliminaries: Complex Numbers and Euler’s Equation",
    "text": "2 Preliminaries: Complex Numbers and Euler’s Equation\nBefore talking about sinusoids or time domain signals, let’s start by coming to grips with Euler’s equation. Let’s start by asking the question, what does it mean to raise a number to an imaginary power?\n\\[ e^i = ?\\]\nExponential notation, \\(e^a\\), naivly seems to imply \\(a\\) repeated multiplications of \\(e\\). However, recall that exponents have been extended from natural numbers to whole numbers (\\(e^0 = 1\\)), integers (\\(e^{-a} = 1/e^a\\)), rational numbers (\\(e^{1/2} = \\sqrt{e}\\)), and real numbers (\\(e^\\pi - \\pi = 20\\)). None of these hold on to the concept of repeated multiplication. Instead, they use a different property of exponentiation to derive these relationships (namely, \\(e^ae^b=e^{a+b} \\implies \\exp(a)\\exp(b) = \\exp(a+b)\\)).\nThe properties of exponentials can be generalized further to accept complex inputs. Just like how exponentiation can be generalized from repeated multiplication to a function that relates the product of outputs to the sum of inputs, it can be generalized again such that it is a function that is its own derivative.\n\\[\ne^x = \\frac{\\text{d}e^x}{\\text{d}x}\n\\]\nWe will first derive Euler’s Equation, then examine some of its properties.\n\n2.1 Deriving Euler’s Equation from Picard Iterates\nSay we want to define a function, \\(f(x)\\), that is equal to its own derivative. \\[f(x) = f'(x)\\]\nYou may already know what the answer is, but let’s try to rederive it. We’ll start by making a guess. \\[f_0(x) = 1\\]\nThis is a pretty bad guess. We know that \\(f_0'(x) = 0\\), but we need \\(f_0'(x) = f_0(x) = 1\\).\nWatch how we’ll improve this iteratively (for a truly rigorous treatment, see Picard Iterates).\n\\[\\begin{align}\nf_0(x) &= 1 \\\\\nf'_0(x) &= 0\\\\\n\\\\\nf_1(x) &= 1+x \\\\\nf_1'(x) &= 1\\\\\n\\\\\nf_2(x) &= 1 + x + \\frac{1}{2}x^2 \\\\\nf'_2(x) &= 1 + x\\\\\n\n&\\vdots \\\\\n\nf(x) &= 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\dots = \\sum_{k=0}^\\infty \\frac{x^k}{k!}\\\\\nf'(x) &= 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\dots = \\sum_{k=0}^\\infty \\frac{x^k}{k!}\n\\end{align}\\]\nWe end up with a familiar equation for the Taylor expansion of \\(e^x\\). Notationally, we can keep the form of \\(e^x\\), but semantically we should refer to this infinite sum.\n\n\n\n\n\n\nExercise\n\n\n\nVerify that this does in fact satisfy the product rule for exponentials (\\(e^ae^b = e^{a+b}\\)). Convince yourself that every other property of exponentials will hold.\n\n\nWith this form, we can simply plug in \\(i\\) as an argument to see what the result is. In other words: \\[e^i = 1 +i +\\frac{-1}{2} + i\\frac{-1}{3!} +\\dots\\]\nThe above is just some complex number. It doesn’t really simplify well, but we can try extracting some structure by evaluating \\(e^{i\\theta}\\) where \\(\\theta \\in \\mathbb R\\).\n\\[e^{i\\theta} = 1 + i\\theta + \\frac{-\\theta^2}{2} + i\\frac{-\\theta^3}{3!} + \\dots \\\\\n= \\left(1 - \\frac{\\theta^2}{2} + \\dots \\right) + i\\left(\\theta - \\frac{\\theta^3}{3!} + \\dots \\right)\\]\nIf you recall your Taylor Series, you may recognize the right hand side as the series for \\(\\cos{\\theta}\\) and \\(\\sin{\\theta}\\). Resulting in\n\\[e^{i\\theta} = \\cos{\\theta} + i\\sin{\\theta}\\]\nThus, we rederive Euler’s Equation.\n\nThe complex exponential of every other base can be obtained by recalling the property that \\(a^{i\\theta} = (e^{\\ln a})^{i\\theta} = e^{i\\theta\\ln a}\\)\n\n\n\n2.2 Properties of Euler’s Equation\nEuler’s equation evaluates to some complex number whose real part is \\(\\cos{\\theta}\\) and whose imaginary part is \\(\\sin{\\theta}\\). On the complex plane, this can represent any point on the unit circle. Scaling the entire expression by a constant magnitude \\(M\\) results in scaling that radius by \\(M\\). Adding a phase shift \\(\\phi\\) results in a rotation around the origin by \\(\\phi\\) radians.\n\\[Me^{i(\\theta + \\phi)} = M\\cos{(\\theta + \\phi)} + iM\\sin{(\\theta+ \\phi)}\\]\n\n\nCode\nimport {slider} from \"@jashkenas/inputs\"\nviewof angle = slider(\n  {\n    min: -2*Math.PI, \n    max: 2*Math.PI,\n    step: .01,\n    value: 0,\n    label: \"angle\",\n    format: v =&gt; \"θ [radians]: \" + v.toFixed(2)\n  },\n)\nviewof phase_shift = slider(\n  {\n    min: -Math.PI,\n    max: Math.PI,\n    step: .01,\n    value: 0,\n    label: \"phase shift\",\n    format: v =&gt; \"φ [radians]: \" + v.toFixed(2)\n  },\n)\nviewof magnitude = slider(\n  {\n    min: 0,\n    max: 2,\n    step: .01,\n    value: 1,\n    label: \"magnitude\",\n    format: v =&gt; \"M [magnitude]: \" + v.toFixed(2)\n  },\n)\n\npoint = [\n  {real: 0, imaginary: 0},\n  {real: magnitude*Math.cos(angle + phase_shift), imaginary: magnitude*Math.sin(angle + phase_shift)},\n]\n\nangle_mark_func = angle =&gt; 0.5 + angle / (2*Math.PI * 10)\nangle_points = Array.from(\n  {length: 50}, (_, i) =&gt; {\n    const t = angle * i / 49\n    return {real: magnitude * angle_mark_func(t) * Math.cos(t), imaginary: magnitude * angle_mark_func(t) * Math.sin(t)}\n  }\n)\n\nphase_mark_func = phase_shift =&gt; angle_mark_func(angle) + phase_shift / (2*Math.PI * 10)\nphase_shift_points = Array.from(\n  {length: 50}, (_, i) =&gt; {\n    const t = phase_shift * i / 49\n    return {real: magnitude * phase_mark_func(t) * Math.cos(t + angle), imaginary: magnitude * phase_mark_func(t) * Math.sin(t + angle)}\n  }\n)\n\nPlot.plot({\n  x: {\n    label: \"Real\",\n    domain: [-2, 2],\n  },\n  y: {\n    label: \"Imaginary\",\n    domain: [-2, 2],\n  },\n  ratio: 1,\n  width: 400,\n  height: 400,\n  marks: [\n    Plot.dot(point, {x: \"real\", y: \"imaginary\"}),\n    Plot.line(point, {x: \"real\", y: \"imaginary\"}),\n    Plot.ruleY([0], {stroke: \"black\", strokeWidth: 1}),\n    Plot.ruleX([0], {stroke: \"black\", strokeWidth: 1}),\n    Plot.line(angle_points, {x: \"real\", y: \"imaginary\", stroke: \"blue\", strokeWidth: 4}),\n    Plot.line(phase_shift_points, {x: \"real\", y: \"imaginary\", stroke: \"red\", strokeWidth: 2}),\n  ],\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNotice, a pure sinusoid can be extracted by taking either the real or imaginary part of the complex exponential. Cosines and sines are just a phase shift away from each other, so the choice is arbitrary. Conventionally, the real part is used. Thus, any sinusoid can be represented as follows.\n\\[\nM\\cos{(\\theta + \\phi)} = \\Re\\left(M e^{i(\\theta + \\phi)}\\right)\n\\]\nOne benefit of this representation is that we can now use the product rule for exponentials to simplify sinusoids without needing to apply trigonometric identities.\n\\[\n\\begin{align*}\n\\cos{(\\theta_1 + \\theta_2)} &= \\Re\\left(e^{i(\\theta_1 + \\theta_2)}\\right) \\\\\n&= \\Re\\left(e^{i\\theta_1}e^{i\\theta_2}\\right) \\\\\n&= \\Re\\left((\\cos{\\theta_1} + i\\sin{\\theta_1}\\right)\\left(\\cos{\\theta_2} + i\\sin{\\theta_2})\\right) \\\\\n&= \\Re\\left(\\cos{\\theta_1}\\cos{\\theta_2} - \\sin{\\theta_1}\\sin{\\theta_2} + i\\left(\\sin{\\theta_1}\\cos{\\theta_2} + \\cos{\\theta_1}\\sin{\\theta_2}\\right)\\right) \\\\\n&= \\cos{\\theta_1}\\cos{\\theta_2} - \\sin{\\theta_1}\\sin{\\theta_2}\n\\end{align*}\n\\]\nAnother benefit is that it provides a way to visually represent the sum of sinusoids as vector addition. Consider the following example where we add two sinusoids. The green line in the plot below represents the real part of the sum.\n\\[\n\\begin{align*}\nM_1\\cos{(\\theta_1)} + M_2\\cos{(\\theta_2)} &= \\Re\\left(M_1 e^{i\\theta_1} + M_2 e^{i\\theta_2}\\right) \\\\\n\\end{align*}\n\\]\n\n\nCode\nviewof angle_1 = slider(\n  {\n    min: -2*Math.PI, \n    max: 2*Math.PI,\n    step: .01,\n    value: 0,\n    label: \"angle_1\",\n    format: v =&gt; \"θ₁ [radians]: \" + v.toFixed(2)\n  },\n)\nviewof magnitude_1 = slider(\n  {\n    min: 0,\n    max: 2,\n    step: .01,\n    value: 1,\n    label: \"magnitude_1\",\n    format: v =&gt; \"M₁ [magnitude]: \" + v.toFixed(2)\n  },\n)\nviewof angle_2 = slider(\n  {\n    min: -Math.PI,\n    max: Math.PI,\n    step: .01,\n    value: 0,\n    label: \"angle_2\",\n    format: v =&gt; \"θ₂ [radians]: \" + v.toFixed(2)\n  },\n)\nviewof magnitude_2 = slider(\n  {\n    min: 0,\n    max: 2,\n    step: .01,\n    value: 1,\n    label: \"magnitude_2\",\n    format: v =&gt; \"M₂ [magnitude]: \" + v.toFixed(2)\n  },\n)\n\nsum_points = [\n  {real: 0, imaginary: 0},\n  {real: magnitude_1*Math.cos(angle_1), imaginary: magnitude_1*Math.sin(angle_1)},\n  {real: magnitude_1*Math.cos(angle_1) + magnitude_2*Math.cos(angle_2), imaginary: magnitude_1*Math.sin(angle_1) + magnitude_2*Math.sin(angle_2)},\n]\n\nreal_marker = [\n    {real: 0, imaginary: magnitude_1*Math.sin(angle_1) + magnitude_2*Math.sin(angle_2)},\n    {real: magnitude_1*Math.cos(angle_1)+magnitude_2*Math.cos(angle_2), imaginary: magnitude_1*Math.sin(angle_1) + magnitude_2*Math.sin(angle_2)},\n]\n\nPlot.plot({\n  x: {\n    label: \"Real\",\n    domain: [-4, 4],\n  },\n  y: {\n    label: \"Imaginary\",\n    domain: [-4, 4],\n  },\n  ratio: 1,\n  width: 400,\n  height: 400,\n  marks: [\n    Plot.dot(sum_points, {x: \"real\", y: \"imaginary\"}),\n    Plot.line(sum_points, {x: \"real\", y: \"imaginary\"}),\n    Plot.ruleY([0], {stroke: \"black\", strokeWidth: 1}),\n    Plot.ruleX([0], {stroke: \"black\", strokeWidth: 1}),\n    Plot.line(real_marker, {x: \"real\", y: \"imaginary\", stroke: \"green\", strokeWidth: 4}),\n  ],\n})"
  },
  {
    "objectID": "demos/phasors/phasors.html#phasors",
    "href": "demos/phasors/phasors.html#phasors",
    "title": "Phasors",
    "section": "3 Phasors",
    "text": "3 Phasors\nA phasor is a representation of a sinusoidal signal (with some frequency) as a single complex number. Doing this allows you to leverage the nice properties of complex exponentials described above. We’ll start by describing why it works, then going through examples for signals with only a time component and then for signals with both a time and space component.\n\n3.1 Why Phasors Work\nOften times, we have some arbitrary signal (ie. not a sinusoid) that we want to input into some linear system. That is, a system where the outputs and inputs follow the rules of superposition. Explicitly, scaling the input by a constant will scale the output by the same constant. Inputting the sum of two signals will result in an output that is the sum of their individual outputs. Many systems in physics and engineering can be modeled as linear systems (eg. electrical circuits, spring-mass-damper systems).\nFourier analysis tells us that any signal (even those that are not periodic) can be decomposed into a linear combination of sinusoids. So understanding how a system transforms sinusoidal signals is sufficient to understand how it transforms any signal.\nLinear systems theory tells us that inputting a sinusoidal signal into a linear system results in an output that has the same frequency, but may have a different amplitude and phase shift. In other words, you only need to track how the magnitude and phase of the sinusoid changes to get a full understanding of the transformation (at that frequency).\nSo if we have some input signal \\(x(t) = M \\cos{(\\omega t + \\phi)}\\), we know the output will be of the form \\(y(t) = M' \\cos{(\\omega t + \\phi')}\\). Representing the input as a complex exponential, we have the following.\n\\[\n\\begin{align*}\nx(t) &= \\Re \\left( M e^{i(\\omega t+ \\phi) }\\right) \\\\\n&= \\Re \\left( M e^{i\\omega t} e^{i\\phi} \\right)\n\\end{align*}\n\\]\nBut recall, we don’t need to track the frequency of the sinusoid as we know that will stay the same. So we can simply represent the phasor version of the sinusoid, \\(\\tilde X\\), as a complex number with a magnitude \\(M\\) and phase \\(\\phi\\). \\[\n\\begin{gather*}\n\\tilde X = M e^{i\\phi} = M \\angle \\phi \\\\\nx(t) = \\Re\\left(\\tilde X e^{i\\omega t}\\right)\n\\end{gather*}\n\\]\nThe two lines above describe the forward and inverse phasor transforms. Typically, you’ll start in the time domain, transform to the phasor domain where calculations are easier, do some calculations, then transform back to the time domain.\n\n\n3.2 Time Varying Signals\nAgain, any signal (including aperiodic ones) can be decomposed into a linear combination of sinusoids. We will analyze a simple sinusoidal signal, \\(s(t) = M \\cos{(\\omega t + \\phi)}\\) which has a magnitude \\(M\\), angular frequency \\(\\omega\\), and constant phase shift \\(\\phi\\). This is representative, for example, of a sinusoidal voltage signal on a low frequency or physically short circuit.\nWe can view this signal as a phasor evolving in time and as a voltage across space evolving in time. The plot on the left depicts the signal in phase domain while the plot on the right depicts space domain. Notice, the voltage is constant across space (as expected for something obeying Kirchoff’s Voltage Law).\n\n\nCode\nimport {Scrubber} from \"@mbostock/scrubber\"\n\ntime_duration_time_single = 2*Math.PI / omega_time_single\nfps = 20\ndt = 1/fps\n\nviewof t_time_single = Scrubber(d3.ticks(0, time_duration_time_single, time_duration_time_single*fps), {\n  autoplay: false,\n  loop: true,\n  initial: 0,\n  format: x =&gt; `t [seconds] = ${x.toFixed(2)}`,\n  delay: dt * 1000\n})\nviewof omega_time_single = slider(\n  {\n    min: .01,\n    max: Math.PI,\n    step: .01,\n    value: 1,\n    label: \"angular frequency\",\n    format: v =&gt; \"ω [radians/second]: \" + v.toFixed(2)\n  },\n)\nviewof phase_time_single = slider(\n  {\n    min: -Math.PI,\n    max: Math.PI,\n    step: .01,\n    value: 0,\n    label: \"phase shift\",\n    format: v =&gt; \"φ [radians]: \" + v.toFixed(2)\n  },\n)\nviewof magnitude_time_single = slider(\n  {\n    min: 0,\n    max: 2,\n    step: .01,\n    value: 1,\n    label: \"magnitude\",\n    format: v =&gt; \"M [magnitude]: \" + v.toFixed(2)\n  },\n)\n\nphasor_time_single = [\n  {real: magnitude_time_single*Math.cos(omega_time_single*t_time_single + phase_time_single),\n  imaginary: magnitude_time_single*Math.sin(omega_time_single*t_time_single + phase_time_single)},\n]\nphasor_phase_time_single = [\n  {real: 0, imaginary: 0},\n  {real: phasor_time_single[0].real,\n  imaginary: phasor_time_single[0].imaginary},\n]\nphasor_space_time_single = [\n  {space: 0, amplitude: phasor_time_single[0].real},\n  {space: 10, amplitude: phasor_time_single[0].real},\n]\n\n{\n  const phase_plot = Plot.plot({\n    x: {\n      label: \"Real\",\n      domain: [-2, 2],\n    },\n    y: {\n      label: \"Imaginary\",\n      domain: [-2, 2],\n    },\n    ratio: 1,\n    width: 400,\n    marks: [\n      Plot.ruleY([0], {stroke: \"black\", strokeWidth: 1}),\n      Plot.ruleX([0], {stroke: \"black\", strokeWidth: 1}),\n\n      Plot.dot(phasor_time_single, {x: \"real\", y: \"imaginary\"}),\n      Plot.line(phasor_phase_time_single, {x: \"real\", y: \"imaginary\"}),\n      Plot.line(\n        phasor_phase_time_single.map(d =&gt; ({real: d.real, imaginary: phasor_time_single[0].imaginary})),\n        {x: \"real\", y: \"imaginary\", stroke: \"blue\", strokeWidth: 4}\n      ),\n    ],\n  })\n\n  const space_plot = Plot.plot({\n    x: {\n      label: \"Space\",\n      domain: [0, 10],\n    },\n    y: {\n      label: \"Amplitude\",\n      domain: [-2, 2],\n    },\n    ratio: 1,\n    width: 400,\n    marks: [\n      Plot.ruleY([0], {stroke: \"black\", strokeWidth: 1}),\n      Plot.ruleX([0], {stroke: \"black\", strokeWidth: 1}),\n      Plot.line(\n        phasor_phase_time_single.map(d =&gt; ({space: 0, amplitude: d.real})),\n        {x: \"space\", y: \"amplitude\", stroke: \"blue\", strokeWidth: 4}),\n      Plot.dot(phasor_time_single.map(d =&gt; ({space: 0, amplitude: d.real})), {x: \"space\", y: \"amplitude\"}),\n      Plot.line(phasor_space_time_single, {x: \"space\", y: \"amplitude\", stroke: \"red\", strokeWidth: 2}),\n    ],\n  })\n\n  return html`&lt;div style=\"display:flex; gap:20px\"&gt;\n    &lt;h3&gt; Phase Domain\n    ${phase_plot}\n    &lt;h3&gt; Space Domain\n    ${space_plot}\n  &lt;\\div&gt;`\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor the rest of this subsection, we’ll show the time domain instead, as the space domain is rather boring when the function is not space varying. Just know that the voltage is constant across space in these cases where the function is only time varying.\nIt’s worth noting that the amplitude at any point in time can be found as long as you know what the magnitude and phase of the phasor are at any point in time. By convention, knowing the initial condition (magnitude and phase at \\(t=0\\)) is sufficient to fully describe the phasor.\nWe can also add two voltage signals together. In phase space, adding two signals has the appearance of vector addition. Let’s first look at the case where we have two signals with the same frequency. That is:\n\\[\ns(t) = M_1 \\cos{(\\omega t + \\phi_1)} + M_2 \\cos{(\\omega t + \\phi_2)}\n\\]\n\n\nCode\ntime_duration_match_freq = 10\ntime_array_match_freq = d3.ticks(0, time_duration_match_freq, time_duration_match_freq*fps)\n\nviewof t_match_freq = Scrubber(d3.ticks(0, time_duration_match_freq, time_duration_match_freq*fps), {\n  autoplay: false,\n  loop: true,\n  initial: 0,\n  format: x =&gt; `t [seconds] = ${x.toFixed(2)}`,\n  delay: dt * 1000\n})\nviewof omega_match_freq = slider(\n  {\n    min: .01,\n    max: Math.PI,\n    step: .01,\n    value: 1,\n    label: \"angular frequency\",\n    format: v =&gt; \"ω [radians/second]: \" + v.toFixed(2)\n  },\n)\nviewof phase_1_match_freq = slider(\n  {\n    min: -Math.PI,\n    max: Math.PI,\n    step: .01,\n    value: .5,\n    label: \"phase shift\",\n    format: v =&gt; \"φ₁ [radians]: \" + v.toFixed(2)\n  },\n)\nviewof magnitude_1_match_freq = slider(\n  {\n    min: 0,\n    max: 2,\n    step: .01,\n    value: 1.4,\n    label: \"magnitude\",\n    format: v =&gt; \"M₁ [magnitude]: \" + v.toFixed(2)\n  },\n)\nviewof phase_2_match_freq = slider(\n  {\n    min: -Math.PI,\n    max: Math.PI,\n    step: .01,\n    value: -0.2,\n    label: \"phase shift\",\n    format: v =&gt; \"φ₂ [radians]: \" + v.toFixed(2)\n  },\n)\nviewof magnitude_2_match_freq = slider(\n  {\n    min: 0,\n    max: 2,\n    step: .01,\n    value: 0.8,\n    label: \"magnitude\",\n    format: v =&gt; \"M₂ [magnitude]: \" + v.toFixed(2)\n  },\n)\n\nfunction calculatePhasor(angle, pos_angle, magnitude, phase_shift) {\n  return {\n    real: magnitude * Math.cos(angle + pos_angle + phase_shift),\n    imaginary: magnitude * Math.sin(angle + pos_angle + phase_shift)\n  }\n}\n\npoints_time_match_freq = Array.from(\n  {length: time_array_match_freq.length}, (_, i) =&gt; {\n    return {\n      time: time_array_match_freq[i],\n      amplitude: calculatePhasor(omega_match_freq * time_array_match_freq[i], 0, magnitude_1_match_freq, phase_1_match_freq).real + \n                calculatePhasor(omega_match_freq * time_array_match_freq[i], 0, magnitude_2_match_freq, phase_2_match_freq).real\n    }\n  }\n)\n\npoint_1_match_freq = calculatePhasor(omega_match_freq*t_match_freq, 0, magnitude_1_match_freq, phase_1_match_freq)\npoint_2_match_freq = calculatePhasor(omega_match_freq*t_match_freq, 0, magnitude_2_match_freq, phase_2_match_freq)\npoint_sum_match_freq = [{\n  real: point_1_match_freq.real + point_2_match_freq.real,\n  imaginary: point_1_match_freq.imaginary + point_2_match_freq.imaginary\n}]\n\n{\n  const phase_plot = Plot.plot({\n    x: {\n      label: \"Real\",\n      domain: [-4, 4],\n    },\n    y: {\n      label: \"Imaginary\",\n      domain: [-4, 4],\n    },\n    ratio: 1,\n    width: 400,\n    marks: [\n      Plot.ruleY([0], {stroke: \"black\", strokeWidth: 1}),\n      Plot.ruleX([0], {stroke: \"black\", strokeWidth: 1}),\n\n      Plot.line([{real: 0, imaginary: 0}, point_1_match_freq], {x: \"real\", y: \"imaginary\", stroke: \"green\", strokeWidth: 2}),\n      Plot.line([{real: 0, imaginary: 0}, point_2_match_freq], {x: \"real\", y: \"imaginary\", stroke: \"orange\", strokeWidth: 2}),\n      Plot.line([point_1_match_freq, point_sum_match_freq[0], point_2_match_freq], {x: \"real\", y: \"imaginary\", strokeWidth: 2}),\n      Plot.line([{real: 0, imaginary: point_sum_match_freq[0].imaginary}, point_sum_match_freq[0]], {x: \"real\", y: \"imaginary\", stroke: \"blue\", strokeWidth: 4}),\n      Plot.dot(point_sum_match_freq, {x: \"real\", y: \"imaginary\"}),\n    ],\n  })\n\n  const time_plot = Plot.plot({\n    x: {\n      label: \"Time\",\n      domain: [0, time_duration_match_freq],\n    },\n    y: {\n      label: \"Amplitude\",\n      domain: [-4, 4],\n    },\n    ratio: 1,\n    width: 400,\n    marks: [\n      Plot.ruleY([0], {stroke: \"black\", strokeWidth: 1}),\n      Plot.ruleX([0], {stroke: \"black\", strokeWidth: 1}),\n\n      Plot.line([{time: t_match_freq, amplitude: 0}, {time: t_match_freq, amplitude: point_sum_match_freq[0].real}], {x: \"time\", y: \"amplitude\", stroke: \"blue\", strokeWidth: 4}),\n      Plot.line(points_time_match_freq, {x: \"time\", y: \"amplitude\", stroke: \"red\", strokeWidth: 2}),\n      Plot.dot([{time: t_match_freq, amplitude: point_sum_match_freq[0].real}], {x: \"time\", y: \"amplitude\"}),\n    ],\n  })\n\n  return html`&lt;div style=\"display:flex; gap:20px\"&gt;\n    &lt;h3&gt; Phase Domain\n    ${phase_plot}\n    &lt;h3&gt; Time Domain\n    ${time_plot}\n  &lt;\\div&gt;`\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNotice, the two phasors being summed (green and yellow) are locked in phase, keeping a constant parallelogram shape that rotates around the origin together. Viewed this way, it becomes clear that the sum of two sinusoids with the same frequency will always be another sinusoid.\nNow let’s see what happens when we add two signals with different frequencies. It’s important to note that when mathematically manipulating phasors, we assume they always have the same frequency. However, we can still visualize the sum of these two signals in the phasor domain. If you’re familiar with the beat frequency phenomenon, you may recognize this as the same effect.\n\n\nCode\ntime_duration_diff_freq = 30\ntime_array_diff_freq = d3.ticks(0, time_duration_diff_freq, time_duration_diff_freq*fps)\n\nviewof t_diff_freq = Scrubber(d3.ticks(0, time_duration_diff_freq, time_duration_diff_freq*fps), {\n  autoplay: false,\n  loop: true,\n  initial: 0,\n  format: x =&gt; `t [seconds] = ${x.toFixed(2)}`,\n  delay: dt * 1000\n})\nviewof omega_1_diff_freq = slider(\n  {\n    min: .01,\n    max: Math.PI,\n    step: .01,\n    value: 1,\n    label: \"angular frequency\",\n    format: v =&gt; \"ω₁ [radians/second]: \" + v.toFixed(2)\n  },\n)\nviewof phase_1_diff_freq = slider(\n  {\n    min: -Math.PI,\n    max: Math.PI,\n    step: .01,\n    value: .5,\n    label: \"phase shift\",\n    format: v =&gt; \"φ₁ [radians]: \" + v.toFixed(2)\n  },\n)\nviewof magnitude_1_diff_freq = slider(\n  {\n    min: 0,\n    max: 2,\n    step: .01,\n    value: 1.4,\n    label: \"magnitude\",\n    format: v =&gt; \"M₁ [magnitude]: \" + v.toFixed(2)\n  },\n)\nviewof omega_2_diff_freq = slider(\n  {\n    min: .01,\n    max: Math.PI,\n    step: .01,\n    value: 3,\n    label: \"angular frequency\",\n    format: v =&gt; \"ω₂ [radians/second]: \" + v.toFixed(2)\n  },\n)\nviewof phase_2_diff_freq = slider(\n  {\n    min: -Math.PI,\n    max: Math.PI,\n    step: .01,\n    value: -0.2,\n    label: \"phase shift\",\n    format: v =&gt; \"φ₂ [radians]: \" + v.toFixed(2)\n  },\n)\nviewof magnitude_2_diff_freq = slider(\n  {\n    min: 0,\n    max: 2,\n    step: .01,\n    value: 0.8,\n    label: \"magnitude\",\n    format: v =&gt; \"M₂ [magnitude]: \" + v.toFixed(2)\n  },\n)\n\npoints_time_diff_freq = Array.from(\n  {length: time_array_diff_freq.length}, (_, i) =&gt; {\n    return {\n      time: time_array_diff_freq[i],\n      amplitude: calculatePhasor(omega_1_diff_freq * time_array_diff_freq[i], 0, magnitude_1_diff_freq, phase_1_diff_freq).real + \n                calculatePhasor(omega_2_diff_freq * time_array_diff_freq[i], 0, magnitude_2_diff_freq, phase_2_diff_freq).real\n    }\n  }\n)\n\npoint_1_diff_freq = calculatePhasor(omega_1_diff_freq*t_diff_freq, 0, magnitude_1_diff_freq, phase_1_diff_freq)\npoint_2_diff_freq = calculatePhasor(omega_2_diff_freq*t_diff_freq, 0, magnitude_2_diff_freq, phase_2_diff_freq)\npoint_sum_diff_freq = [{\n  real: point_1_diff_freq.real + point_2_diff_freq.real,\n  imaginary: point_1_diff_freq.imaginary + point_2_diff_freq.imaginary\n}]\n\n{\n  const phase_plot = Plot.plot({\n    x: {\n      label: \"Real\",\n      domain: [-4, 4],\n    },\n    y: {\n      label: \"Imaginary\",\n      domain: [-4, 4],\n    },\n    ratio: 1,\n    width: 400,\n    marks: [\n      Plot.ruleY([0], {stroke: \"black\", strokeWidth: 1}),\n      Plot.ruleX([0], {stroke: \"black\", strokeWidth: 1}),\n\n      Plot.line([{real: 0, imaginary: 0}, point_1_diff_freq], {x: \"real\", y: \"imaginary\", stroke: \"green\", strokeWidth: 2}),\n      Plot.line([{real: 0, imaginary: 0}, point_2_diff_freq], {x: \"real\", y: \"imaginary\", stroke: \"orange\", strokeWidth: 2}),\n      Plot.line([point_1_diff_freq, point_sum_diff_freq[0], point_2_diff_freq], {x: \"real\", y: \"imaginary\", strokeWidth: 2}),\n      Plot.line([{real: 0, imaginary: point_sum_diff_freq[0].imaginary}, point_sum_diff_freq[0]], {x: \"real\", y: \"imaginary\", stroke: \"blue\", strokeWidth: 4}),\n      Plot.dot(point_sum_diff_freq, {x: \"real\", y: \"imaginary\"}),\n    ],\n  })\n\n  const time_plot = Plot.plot({\n    x: {\n      label: \"Time\",\n      domain: [0, time_duration_diff_freq],\n    },\n    y: {\n      label: \"Amplitude\",\n      domain: [-4, 4],\n    },\n    ratio: 1,\n    width: 400,\n    marks: [\n      Plot.ruleY([0], {stroke: \"black\", strokeWidth: 1}),\n      Plot.ruleX([0], {stroke: \"black\", strokeWidth: 1}),\n\n      Plot.line([{time: t_diff_freq, amplitude: 0}, {time: t_diff_freq, amplitude: point_sum_diff_freq[0].real}], {x: \"time\", y: \"amplitude\", stroke: \"blue\", strokeWidth: 4}),\n      Plot.line(points_time_diff_freq, {x: \"time\", y: \"amplitude\", stroke: \"red\", strokeWidth: 2}),\n      Plot.dot([{time: t_diff_freq, amplitude: point_sum_diff_freq[0].real}], {x: \"time\", y: \"amplitude\"}),\n    ],\n  })\n\n  return html`&lt;div style=\"display:flex; gap:20px\"&gt;\n    &lt;h3&gt; Phase Domain\n    ${phase_plot}\n    &lt;h3&gt; Time Domain\n    ${time_plot}\n  &lt;\\div&gt;`\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhen the phasor vectors are aligned, they sum. When they are anti-aligned, they cancel out. It’s also fun to mess around with the relative magnitudes and phases of the two signals to see how they interact. Importantly, we see that differing frequencies results in a parallelogram that warps over time, it becomes clear that we should not have a clean sinusoid anymore.\n\n\n3.3 Time and Space Varying Signals\nWaves, in classical physics, are some disturbance that propagates through space and time. To represent this mathematically, the standard linear wave need only be a function of a linear combination of space and time. For instance, the function \\(f(x, t) = (\\omega t - kx)^2\\) depicts a quadratic function propagating forwards as a wave.\n\n\nCode\nviewof time_quad = Scrubber(Array.from({length: 101}, (_, i) =&gt; i / 10),\n  {\n    autoplay: false,\n    loop: false,\n    initial: 0,\n    format: v =&gt; \"t [seconds]: \" + v.toFixed(2),\n  },\n)\n\nquad_func = x =&gt; (time_quad - x)**2\nquad_points = Array.from(\n  {length: 50}, (_, i) =&gt; {\n    const x = i / 49 * 10\n    return {y: quad_func(x), x: x}\n  }\n)\n\nPlot.plot({\n  x: {\n    label: \"Space\",\n    domain: [0, 10],\n  },\n  y: {\n    label: \"Amplitude\",\n    domain: [-1, 4],\n  },\n  ratio: 1,\n  width: 400,\n  marks: [\n    Plot.line(quad_points, {x: \"x\", y: \"y\"}),\n    Plot.ruleY([0], {stroke: \"black\", strokeWidth: 1}),\n    Plot.ruleX([0], {stroke: \"black\", strokeWidth: 1}),\n  ],\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUnderstanding why is a topic for another time (including why the spatial term is negative). For now, recall that any signal can be decomposed into a linear combination of sinusoids, so understanding how a sinusoidal wave propagates is sufficient to understand how any general wave propagates.\nTo make a sinusoid a wave, we simply make its argument a linear combination of space and time. Consider the following expression.\n\\[\n\\begin{gather*}\ns(t, x) = M \\cos{(\\omega t - kx + \\phi)} = \\Re\\left(M e^{i(\\omega t - kx + \\phi)}\\right) \\\\\n\\tilde S = M e^{i\\phi}\n\\end{gather*}\n\\]\nWe keep the convention of ignoring the variable parameters in the phasor representation. Like in the time varying case, knowing the initial conditions (magnitude and phase at \\(t=0\\)) is sufficient to fully describe the signal at any point in time or space. For this subsection, we’ll bring back the space domain plot as well, as the function is now space varying.\n\n\nCode\ntime_duration_spacetime = 10\nspace_dist_spacetime = 10\nspace_array_spacetime = d3.ticks(0, space_dist_spacetime, space_dist_spacetime*fps)\n\nviewof t_spacetime = Scrubber(d3.ticks(0, time_duration_spacetime, time_duration_spacetime*fps), {\n  autoplay: false,\n  loop: true,\n  initial: 0,\n  format: x =&gt; `t [seconds] = ${x.toFixed(2)}`,\n  delay: dt * 1000\n})\nviewof x_spacetime = slider(\n  {\n    min: 0,\n    max: space_dist_spacetime,\n    step: .01,\n    value: 0,\n    label: \"position\",\n    format: v =&gt; \"x [meters]: \" + v.toFixed(2)\n  },\n)\nviewof omega_spacetime = slider(\n  {\n    min: .01,\n    max: Math.PI,\n    step: .01,\n    value: 1,\n    label: \"angular frequency\",\n    format: v =&gt; \"ω [radians/second]: \" + v.toFixed(2)\n  },\n)\nviewof k_spacetime = slider(\n  {\n    min: 0.01,\n    max: Math.PI,\n    step: .01,\n    value: 1,\n    label: \"position\",\n    format: v =&gt; \"k [radians/meter]: \" + v.toFixed(2)\n  },\n)\nviewof phase_spacetime = slider(\n  {\n    min: -Math.PI,\n    max: Math.PI,\n    step: .01,\n    value: 0,\n    label: \"phase shift\",\n    format: v =&gt; \"φ [radians]: \" + v.toFixed(2)\n  },\n)\nviewof magnitude_spacetime = slider(\n  {\n    min: 0,\n    max: 2,\n    step: .01,\n    value: 1,\n    label: \"magnitude\",\n    format: v =&gt; \"M [magnitude]: \" + v.toFixed(2)\n  },\n)\n\npoints_space_spacetime = Array.from(\n  {length: space_array_spacetime.length}, (_, i) =&gt; {\n    return {\n      space: space_array_spacetime[i],\n      amplitude: calculatePhasor(omega_spacetime * t_spacetime, k_spacetime * space_array_spacetime[i], magnitude_spacetime, phase_spacetime).real\n    }\n  }\n)\n\nphasor_spacetime = [calculatePhasor(omega_spacetime * t_spacetime, k_spacetime * x_spacetime, magnitude_spacetime, phase_spacetime)]\n\n{\n  const phase_plot = Plot.plot({\n    x: {\n      label: \"Real\",\n      domain: [-2, 2],\n    },\n    y: {\n      label: \"Imaginary\",\n      domain: [-2, 2],\n    },\n    ratio: 1,\n    width: 400,\n    marks: [\n      Plot.ruleY([0], {stroke: \"black\", strokeWidth: 1}),\n      Plot.ruleX([0], {stroke: \"black\", strokeWidth: 1}),\n\n      Plot.line([{real: 0, imaginary: 0}, phasor_spacetime[0]], {x: \"real\", y: \"imaginary\"}),\n      Plot.line([{real: 0, imaginary: phasor_spacetime[0].imaginary}, phasor_spacetime[0]], {x: \"real\", y: \"imaginary\", stroke: \"blue\", strokeWidth: 4}),\n      Plot.dot(phasor_spacetime, {x: \"real\", y: \"imaginary\"}),\n    ],\n  })\n\n  const space_plot = Plot.plot({\n    x: {\n      label: \"Space\",\n      domain: [0, 10],\n    },\n    y: {\n      label: \"Amplitude\",\n      domain: [-2, 2],\n    },\n    ratio: 1,\n    width: 400,\n    marks: [\n      Plot.ruleY([0], {stroke: \"black\", strokeWidth: 1}),\n      Plot.ruleX([0], {stroke: \"black\", strokeWidth: 1}),\n\n      Plot.line([{space: x_spacetime, amplitude: 0}, {space: x_spacetime, amplitude: phasor_spacetime[0].real}],\n        {x: \"space\", y: \"amplitude\", stroke: \"blue\", strokeWidth: 4}),\n      Plot.line(points_space_spacetime, {x: \"space\", y: \"amplitude\", stroke: \"red\", strokeWidth: 2}),\n      Plot.dot([{space: x_spacetime, amplitude: phasor_spacetime[0].real}], {x: \"space\", y: \"amplitude\"}),\n    ],\n  })\n\n  return html`&lt;div style=\"display:flex; gap:20px\"&gt;\n    &lt;h3&gt; Phase Domain\n    ${phase_plot}\n    &lt;h3&gt; Space Domain\n    ${space_plot}\n  &lt;\\div&gt;`\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA couple things to note.\n\nAdjusting your position looks like a phase shift in the phase domain (just like time).\nAdjusting \\(k\\) does not change the speed of rotation, just the distance between the peaks of the wave.\n\\(\\omega\\) and \\(k\\) may appear to cause a phase shift in the phase domain, but this is only when \\(t\\) and \\(x\\) are nonzero.\n\nLet’s now look at the case where we sum two waves. There are four cases to considered.\n\nSame temporal frequency, same spatial frequency\nSame temporal frequency, different spatial frequency\nDifferent temporal frequency, same spatial frequency\nDifferent temporal frequency, different spatial frequency\n\n\n3.3.1 Case 1: Same Temporal Frequency, Same Spatial Frequency\nThis case will closely resemble the time varying case when adding two sinusoids of the same frequency. The phasors remain locked in phase, resulting in a constant parallelogram shape that rotates around the origin together. The result is another sinusoid with the same frequency.\nThis is also relatively straightforward to derive mathematically.\n\\[\n\\begin{align*}\ns(t, x) &= M_1 \\cos{(\\omega t - k x + \\phi_1)} + M_2 \\cos{(\\omega t - k x + \\phi_2)} \\\\\n&= \\Re\\left(M_1 e^{i(\\omega t - k x + \\phi_1)} + M_2 e^{i(\\omega t - k x + \\phi_2)}\\right) \\\\\n&= \\Re\\left((M_1 e^{i\\phi_1} + M_2 e^{i\\phi_2}) e^{i(\\omega t - k x)}\\right) \\\\\n&= \\Re\\left(\\tilde S e^{i(\\omega t - k x)}\\right) \\\\\n\\end{align*}\n\\]\nHere, \\(\\tilde S\\) is just some constant complex number. So the result is a sinusoid that is scaled and phase shifted as described by the phasor \\(\\tilde S\\).\n\n\nCode\ntime_duration_sameo_samek = 10\nspace_dist_sameo_samek = 10\nspace_array_sameo_samek = d3.ticks(0, space_dist_sameo_samek, space_dist_sameo_samek*fps)\n\nviewof t_sameo_samek = Scrubber(d3.ticks(0, time_duration_sameo_samek, time_duration_sameo_samek*fps), {\n  autoplay: false,\n  loop: true,\n  initial: 0,\n  format: x =&gt; `t [seconds] = ${x.toFixed(2)}`,\n  delay: dt * 1000\n})\nviewof x_sameo_samek = slider(\n  {\n    min: 0,\n    max: space_dist_sameo_samek,\n    step: .01,\n    value: 0,\n    label: \"position\",\n    format: v =&gt; \"x [meters]: \" + v.toFixed(2)\n  },\n)\nviewof omega_sameo_samek = slider(\n  {\n    min: .01,\n    max: Math.PI,\n    step: .01,\n    value: 1,\n    label: \"angular frequency\",\n    format: v =&gt; \"ω [radians/second]: \" + v.toFixed(2)\n  },\n)\nviewof k_sameo_samek = slider(\n  {\n    min: 0.01,\n    max: Math.PI,\n    step: .01,\n    value: 1,\n    label: \"position\",\n    format: v =&gt; \"k [radians/meter]: \" + v.toFixed(2)\n  },\n)\nviewof phase_1_sameo_samek = slider(\n  {\n    min: -Math.PI,\n    max: Math.PI,\n    step: .01,\n    value: 0.5,\n    label: \"phase shift\",\n    format: v =&gt; \"φ₁ [radians]: \" + v.toFixed(2)\n  },\n)\nviewof magnitude_1_sameo_samek = slider(\n  {\n    min: 0,\n    max: 2,\n    step: .01,\n    value: 1.4,\n    label: \"magnitude\",\n    format: v =&gt; \"M₁ [magnitude]: \" + v.toFixed(2)\n  },\n)\nviewof phase_2_sameo_samek = slider(\n  {\n    min: -Math.PI,\n    max: Math.PI,\n    step: .01,\n    value: -0.2,\n    label: \"phase shift\",\n    format: v =&gt; \"φ₂ [radians]: \" + v.toFixed(2)\n  },\n)\nviewof magnitude_2_sameo_samek = slider(\n  {\n    min: 0,\n    max: 2,\n    step: .01,\n    value: 0.8,\n    label: \"magnitude\",\n    format: v =&gt; \"M₂ [magnitude]: \" + v.toFixed(2)\n  },\n)\n\npoints_space_sameo_samek = Array.from(\n  {length: space_array_sameo_samek.length}, (_, i) =&gt; {\n    return {\n      space: space_array_sameo_samek[i],\n      amplitude: calculatePhasor(omega_sameo_samek * t_sameo_samek, k_sameo_samek * space_array_sameo_samek[i], magnitude_1_sameo_samek, phase_1_sameo_samek).real + \n        calculatePhasor(omega_sameo_samek * t_sameo_samek, k_sameo_samek * space_array_sameo_samek[i], magnitude_2_sameo_samek, phase_2_sameo_samek).real\n    }\n  }\n)\n\npoint_1_sameo_samek = calculatePhasor(omega_sameo_samek*t_sameo_samek, k_sameo_samek * x_sameo_samek, magnitude_1_sameo_samek, phase_1_sameo_samek)\npoint_2_sameo_samek = calculatePhasor(omega_sameo_samek*t_sameo_samek, k_sameo_samek * x_sameo_samek, magnitude_2_sameo_samek, phase_2_sameo_samek)\nphasor_sameo_samek = [\n  {\n    real: point_1_sameo_samek.real + point_2_sameo_samek.real,\n    imaginary: point_1_sameo_samek.imaginary + point_2_sameo_samek.imaginary\n  }\n]\n\n{\n  const phase_plot = Plot.plot({\n    x: {\n      label: \"Real\",\n      domain: [-4, 4],\n    },\n    y: {\n      label: \"Imaginary\",\n      domain: [-4, 4],\n    },\n    ratio: 1,\n    width: 400,\n    marks: [\n      Plot.ruleY([0], {stroke: \"black\", strokeWidth: 1}),\n      Plot.ruleX([0], {stroke: \"black\", strokeWidth: 1}),\n\n      Plot.line([{real: 0, imaginary: 0}, point_1_sameo_samek], {x: \"real\", y: \"imaginary\", stroke: \"green\", strokeWidth: 2}),\n      Plot.line([{real: 0, imaginary: 0}, point_2_sameo_samek], {x: \"real\", y: \"imaginary\", stroke: \"orange\", strokeWidth: 2}),\n      Plot.line([point_1_sameo_samek, phasor_sameo_samek[0], point_2_sameo_samek], {x: \"real\", y: \"imaginary\", strokeWidth: 2}),\n      Plot.line([{real: 0, imaginary: phasor_sameo_samek[0].imaginary}, phasor_sameo_samek[0]], {x: \"real\", y: \"imaginary\", stroke: \"blue\", strokeWidth: 4}),\n      Plot.dot(phasor_sameo_samek, {x: \"real\", y: \"imaginary\"}),\n    ],\n  })\n\n  const space_plot = Plot.plot({\n    x: {\n      label: \"Space\",\n      domain: [0, 10],\n    },\n    y: {\n      label: \"Amplitude\",\n      domain: [-4, 4],\n    },\n    ratio: 1,\n    width: 400,\n    marks: [\n      Plot.ruleY([0], {stroke: \"black\", strokeWidth: 1}),\n      Plot.ruleX([0], {stroke: \"black\", strokeWidth: 1}),\n\n      Plot.line([{space: x_sameo_samek, amplitude: 0}, {space: x_sameo_samek, amplitude: phasor_sameo_samek[0].real}],\n        {x: \"space\", y: \"amplitude\", stroke: \"blue\", strokeWidth: 4}),\n      Plot.line(points_space_sameo_samek, {x: \"space\", y: \"amplitude\", stroke: \"red\", strokeWidth: 2}),\n      Plot.dot([{space: x_sameo_samek, amplitude: phasor_sameo_samek[0].real}], {x: \"space\", y: \"amplitude\"}),\n    ],\n  })\n\n  return html`&lt;div style=\"display:flex; gap:20px\"&gt;\n    &lt;h3&gt; Phase Domain\n    ${phase_plot}\n    &lt;h3&gt; Space Domain\n    ${space_plot}\n  &lt;\\div&gt;`\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.3.2 Case 2: Same Temporal Frequency, Different Spatial Frequency\nThis case is fairly visually interesting. Notice, when the animation is played, the parallelogram defining the sum in phase space does not warp. It simply rotates around the origin. However, the space domain does not depict a simple sinusoid.\nAt any given point in space, the signal will oscillate as a sinusoid with a particular frequency. However, the phase and magnitude of that sinusoid will vary at different points in space. Scrubbing through space while time is paused reveals a pattern in the phase space traced by the warping parallelogram. This is traced by the purple line and will be explained further below.\n\\[\n\\begin{align*}\ns(t, x) &= M_1 \\cos{(\\omega t - k_1 x + \\phi_1)} + M_2 \\cos{(\\omega t - k_2 x + \\phi_2)} \\\\\n&= \\Re\\left(M_1 e^{i(\\omega t - k_1 x + \\phi_1)} + M_2 e^{i(\\omega t - k_2 x + \\phi_2)}\\right) \\\\\n\\end{align*}\n\\]\n\n\nCode\ntime_duration_sameo_diffk = 10\nspace_dist_sameo_diffk = 10\nspace_array_sameo_diffk = d3.ticks(0, space_dist_sameo_diffk, space_dist_sameo_diffk*fps)\n\nviewof t_sameo_diffk = Scrubber(d3.ticks(0, time_duration_sameo_diffk, time_duration_sameo_diffk*fps), {\n  autoplay: false,\n  loop: true,\n  initial: 0,\n  format: x =&gt; `t [seconds] = ${x.toFixed(2)}`,\n  delay: dt * 1000\n})\nviewof x_sameo_diffk = slider(\n  {\n    min: 0,\n    max: space_dist_sameo_diffk,\n    step: .01,\n    value: 0,\n    label: \"position\",\n    format: v =&gt; \"x [meters]: \" + v.toFixed(2)\n  },\n)\nviewof omega_sameo_diffk = slider(\n  {\n    min: .01,\n    max: Math.PI,\n    step: .01,\n    value: 1,\n    label: \"angular frequency\",\n    format: v =&gt; \"ω [radians/second]: \" + v.toFixed(2)\n  },\n)\nviewof k_1_sameo_diffk = slider(\n  {\n    min: -4,\n    max: 4,\n    step: .01,\n    value: 2,\n    label: \"position\",\n    format: v =&gt; \"k₁ [radians/meter]: \" + v.toFixed(2)\n  },\n)\nviewof phase_1_sameo_diffk = slider(\n  {\n    min: -Math.PI,\n    max: Math.PI,\n    step: .01,\n    value: 0.5,\n    label: \"phase shift\",\n    format: v =&gt; \"φ₁ [radians]: \" + v.toFixed(2)\n  },\n)\nviewof magnitude_1_sameo_diffk = slider(\n  {\n    min: 0,\n    max: 2,\n    step: .01,\n    value: 1.4,\n    label: \"magnitude\",\n    format: v =&gt; \"M₁ [magnitude]: \" + v.toFixed(2)\n  },\n)\nviewof k_2_sameo_diffk = slider(\n  {\n    min: -4,\n    max: 4,\n    step: .01,\n    value: 0.5,\n    label: \"position\",\n    format: v =&gt; \"k₂ [radians/meter]: \" + v.toFixed(2)\n  },\n)\nviewof phase_2_sameo_diffk = slider(\n  {\n    min: -Math.PI,\n    max: Math.PI,\n    step: .01,\n    value: -0.2,\n    label: \"phase shift\",\n    format: v =&gt; \"φ₂ [radians]: \" + v.toFixed(2)\n  },\n)\nviewof magnitude_2_sameo_diffk = slider(\n  {\n    min: 0,\n    max: 2,\n    step: .01,\n    value: 0.8,\n    label: \"magnitude\",\n    format: v =&gt; \"M₂ [magnitude]: \" + v.toFixed(2)\n  },\n)\n\npoints_space_sameo_diffk = Array.from(\n  {length: space_array_sameo_diffk.length}, (_, i) =&gt; {\n    return {\n      space: space_array_sameo_diffk[i],\n      amplitude: calculatePhasor(omega_sameo_diffk * t_sameo_diffk, k_1_sameo_diffk * space_array_sameo_diffk[i], magnitude_1_sameo_diffk, phase_1_sameo_diffk).real + \n        calculatePhasor(omega_sameo_diffk * t_sameo_diffk, k_2_sameo_diffk * space_array_sameo_diffk[i], magnitude_2_sameo_diffk, phase_2_sameo_diffk).real\n    }\n  }\n)\n\npoint_1_sameo_diffk = calculatePhasor(omega_sameo_diffk*t_sameo_diffk, k_1_sameo_diffk * x_sameo_diffk, magnitude_1_sameo_diffk, phase_1_sameo_diffk)\npoint_2_sameo_diffk = calculatePhasor(omega_sameo_diffk*t_sameo_diffk, k_2_sameo_diffk * x_sameo_diffk, magnitude_2_sameo_diffk, phase_2_sameo_diffk)\nphasor_sameo_diffk = [\n  {\n    real: point_1_sameo_diffk.real + point_2_sameo_diffk.real,\n    imaginary: point_1_sameo_diffk.imaginary + point_2_sameo_diffk.imaginary\n  }\n]\nphasor_locus_sameo_diffk = Array.from(\n  {length: space_array_sameo_diffk.length}, (_, i) =&gt; {\n    const phasor_1_sameo_diffk = calculatePhasor(omega_sameo_diffk * t_sameo_diffk, k_1_sameo_diffk * space_array_sameo_diffk[i], magnitude_1_sameo_diffk, phase_1_sameo_diffk)\n    const phasor_2_sameo_diffk = calculatePhasor(omega_sameo_diffk * t_sameo_diffk, k_2_sameo_diffk * space_array_sameo_diffk[i], magnitude_2_sameo_diffk, phase_2_sameo_diffk)\n\n    return {\n      real: phasor_1_sameo_diffk.real + phasor_2_sameo_diffk.real,\n      imaginary: phasor_1_sameo_diffk.imaginary + phasor_2_sameo_diffk.imaginary\n    }\n  }\n)\n\n{\n  const phase_plot = Plot.plot({\n    x: {\n      label: \"Real\",\n      domain: [-4, 4],\n    },\n    y: {\n      label: \"Imaginary\",\n      domain: [-4, 4],\n    },\n    ratio: 1,\n    width: 400,\n    marks: [\n      Plot.ruleY([0], {stroke: \"black\", strokeWidth: 1}),\n      Plot.ruleX([0], {stroke: \"black\", strokeWidth: 1}),\n\n      Plot.line([{real: 0, imaginary: 0}, point_1_sameo_diffk], {x: \"real\", y: \"imaginary\", stroke: \"green\", strokeWidth: 2}),\n      Plot.line([{real: 0, imaginary: 0}, point_2_sameo_diffk], {x: \"real\", y: \"imaginary\", stroke: \"orange\", strokeWidth: 2}),\n      Plot.line([point_1_sameo_diffk, phasor_sameo_diffk[0], point_2_sameo_diffk], {x: \"real\", y: \"imaginary\", strokeWidth: 2}),\n      Plot.line([{real: 0, imaginary: phasor_sameo_diffk[0].imaginary}, phasor_sameo_diffk[0]], {x: \"real\", y: \"imaginary\", stroke: \"blue\", strokeWidth: 4}),\n      Plot.dot(phasor_sameo_diffk, {x: \"real\", y: \"imaginary\"}),\n\n      Plot.line(phasor_locus_sameo_diffk, {x: \"real\", y: \"imaginary\", stroke: \"purple\", strokeWidth: 1}),\n    ],\n  })\n\n  const space_plot = Plot.plot({\n    x: {\n      label: \"Space\",\n      domain: [0, 10],\n    },\n    y: {\n      label: \"Amplitude\",\n      domain: [-4, 4],\n    },\n    ratio: 1,\n    width: 400,\n    marks: [\n      Plot.ruleY([0], {stroke: \"black\", strokeWidth: 1}),\n      Plot.ruleX([0], {stroke: \"black\", strokeWidth: 1}),\n\n      Plot.line([{space: x_sameo_diffk, amplitude: 0}, {space: x_sameo_diffk, amplitude: phasor_sameo_diffk[0].real}],\n        {x: \"space\", y: \"amplitude\", stroke: \"blue\", strokeWidth: 4}),\n      Plot.line(points_space_sameo_diffk, {x: \"space\", y: \"amplitude\", stroke: \"red\", strokeWidth: 2}),\n      Plot.dot([{space: x_sameo_diffk, amplitude: phasor_sameo_diffk[0].real}], {x: \"space\", y: \"amplitude\"}),\n    ],\n  })\n\n  return html`&lt;div style=\"display:flex; gap:20px\"&gt;\n    &lt;h3&gt; Phase Domain\n    ${phase_plot}\n    &lt;h3&gt; Space Domain\n    ${space_plot}\n  &lt;\\div&gt;`\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUp until this point, the phase plot had no visual representation of the physical location. The progression of time (in the form of animation) only highlights the temporal components of the signal. We add the locus of all spatial phasor values in purple. In other words, while time is paused, scrubbing through space traces out a loopy path in phase space. We can watch how this path evolves over time.\nIf you experiment a bit, you can begin to understand how this locus changes with the provided parameters. It sort of changes with phase and magnitude, but those only really stretch or shift the locus. The loopiness of the locus and how it loops is really defined by the ratio of the two spatial frequencies. Try making some integer ratios! You’ll notice that positive and negative ratios result in different kinds of loci.\nThis locus can be mathematically modeled as follows. We start with the general expression for the sum of our two waves and transform it into the phasor domain. \\[\n\\begin{align*}\ns(t, x) &= M_1 \\cos{(\\omega t - k_1 x + \\phi_1)} + M_2 \\cos{(\\omega t - k_2 x + \\phi_2)} \\\\\n&= \\Re\\left(M_1 e^{i(\\omega t - k_1 x + \\phi_1)} + M_2 e^{i(\\omega t - k_2 x + \\phi_2)}\\right) \\\\\n&= \\Re\\left((M_1 e^{i\\phi_1} e^{-i k_1 x} + M_2 e^{i\\phi_2} e^{-i k_2 x}) e^{i\\omega t}\\right) \\\\\n\\end{align*}\n\\]\nAt this point, notice that varying time simply applies a rotation to the phasor. Let’s look at just the argument in the inner parentheses and combine constants. Let’s also assume that \\(k_2\\) is an integer multiple of \\(k_1\\). In other words, \\(k_1 = k\\) and \\(k_2 = nk\\) for some integer \\(n\\).\n\\[\nM_1 e^{i\\phi_1} e^{-i k_1 x} + M_2 e^{i\\phi_2} e^{-i k_2 x} = \\tilde M_1 e^{-i k x} + \\tilde M_2 e^{-i nk x}\n\\]\nThis describes a large family of curves that includes things like cardioids, ellipses, lines, circles, epitrochoids, hypotrochoids, and more.\nThe shape of the locus can tell you some information about the signal as well. For instance,\n\nIf the locus is symmetric about the origin, then the signal must have zero mean across space for all time.\nIf the locus is a circle centered on the origin (either magnitude is zero or \\(k_1=k_2\\)), then the signal is a pure sinusoid across space.\nIf the locus is a line (\\(M_1=M_2\\), \\(k_1=-k_2\\)), then the signal is a standing wave.\nIf the locus is an ellipse (\\(k_1 = -k_2\\)), then the signal almost acts as a standing wave but shuffles in space. This is the general description of a sinusoidal wave added to its attenuated reflection.\n\nUnderstanding this locus and how its shape changes with the parameters can provide a lot of insight into why certain combinations of sinusoids results in certain types of waveforms. I highly recommend spending time playing with the parameters here.\n\n\n3.3.3 Case 3: Different Temporal Frequency, Same Spatial Frequency\nThis case will be similar to the preceding one, really it’s equivalent to just being a different perspective of the same thing. So we’ll just skip to the plots.\n\\[\n\\begin{align*}\ns(t, x) &= M_1 \\cos{(\\omega_1 t - k x + \\phi_1)} + M_2 \\cos{(\\omega_2 t - k x + \\phi_2)} \\\\\n&= \\Re\\left(M_1 e^{i(\\omega_1 t - k x + \\phi_1)} + M_2 e^{i(\\omega_2 t - k x + \\phi_2)}\\right) \\\\\n\\end{align*}\n\\]\n\n\nCode\ntime_duration_diffo_samek = 10\nspace_dist_diffo_samek = 10\nspace_array_diffo_samek = d3.ticks(0, space_dist_diffo_samek, space_dist_diffo_samek*fps)\n\nviewof t_diffo_samek = Scrubber(d3.ticks(0, time_duration_diffo_samek, time_duration_diffo_samek*fps), {\n  autoplay: false,\n  loop: true,\n  initial: 0,\n  format: x =&gt; `t [seconds] = ${x.toFixed(2)}`,\n  delay: dt * 1000\n})\nviewof x_diffo_samek = slider(\n  {\n    min: 0,\n    max: space_dist_diffo_samek,\n    step: .01,\n    value: 0,\n    label: \"position\",\n    format: v =&gt; \"x [meters]: \" + v.toFixed(2)\n  },\n)\nviewof k_diffo_samek = slider(\n  {\n    min: -4,\n    max: 4,\n    step: .01,\n    value: 2,\n    label: \"position\",\n    format: v =&gt; \"k [radians/meter]: \" + v.toFixed(2)\n  },\n)\nviewof omega_1_diffo_samek = slider(\n  {\n    min: .01,\n    max: Math.PI,\n    step: .01,\n    value: 1,\n    label: \"angular frequency\",\n    format: v =&gt; \"ω₁ [radians/second]: \" + v.toFixed(2)\n  },\n)\nviewof phase_1_diffo_samek = slider(\n  {\n    min: -Math.PI,\n    max: Math.PI,\n    step: .01,\n    value: 0.5,\n    label: \"phase shift\",\n    format: v =&gt; \"φ₁ [radians]: \" + v.toFixed(2)\n  },\n)\nviewof magnitude_1_diffo_samek = slider(\n  {\n    min: 0,\n    max: 2,\n    step: .01,\n    value: 1.4,\n    label: \"magnitude\",\n    format: v =&gt; \"M₁ [magnitude]: \" + v.toFixed(2)\n  },\n)\nviewof omega_2_diffo_samek = slider(\n  {\n    min: .01,\n    max: Math.PI,\n    step: .01,\n    value: 2,\n    label: \"angular frequency\",\n    format: v =&gt; \"ω₂ [radians/second]: \" + v.toFixed(2)\n  },\n)\nviewof phase_2_diffo_samek = slider(\n  {\n    min: -Math.PI,\n    max: Math.PI,\n    step: .01,\n    value: -0.2,\n    label: \"phase shift\",\n    format: v =&gt; \"φ₂ [radians]: \" + v.toFixed(2)\n  },\n)\nviewof magnitude_2_diffo_samek = slider(\n  {\n    min: 0,\n    max: 2,\n    step: .01,\n    value: 0.8,\n    label: \"magnitude\",\n    format: v =&gt; \"M₂ [magnitude]: \" + v.toFixed(2)\n  },\n)\n\npoints_space_diffo_samek = Array.from(\n  {length: space_array_diffo_samek.length}, (_, i) =&gt; {\n    return {\n      space: space_array_diffo_samek[i],\n      amplitude: calculatePhasor(omega_1_diffo_samek * t_diffo_samek, k_diffo_samek * space_array_diffo_samek[i], magnitude_1_diffo_samek, phase_1_diffo_samek).real + \n        calculatePhasor(omega_2_diffo_samek * t_diffo_samek, k_diffo_samek * space_array_diffo_samek[i], magnitude_2_diffo_samek, phase_2_diffo_samek).real\n    }\n  }\n)\n\npoint_1_diffo_samek = calculatePhasor(omega_1_diffo_samek*t_diffo_samek, k_diffo_samek * x_diffo_samek, magnitude_1_diffo_samek, phase_1_diffo_samek)\npoint_2_diffo_samek = calculatePhasor(omega_2_diffo_samek*t_diffo_samek, k_diffo_samek * x_diffo_samek, magnitude_2_diffo_samek, phase_2_diffo_samek)\nphasor_diffo_samek = [\n  {\n    real: point_1_diffo_samek.real + point_2_diffo_samek.real,\n    imaginary: point_1_diffo_samek.imaginary + point_2_diffo_samek.imaginary\n  }\n]\nphasor_locus_diffo_samek = Array.from(\n  {length: space_array_diffo_samek.length}, (_, i) =&gt; {\n    const phasor_1_diffo_samek = calculatePhasor(omega_1_diffo_samek * t_diffo_samek, k_diffo_samek * space_array_diffo_samek[i], magnitude_1_diffo_samek, phase_1_diffo_samek)\n    const phasor_2_diffo_samek = calculatePhasor(omega_2_diffo_samek * t_diffo_samek, k_diffo_samek * space_array_diffo_samek[i], magnitude_2_diffo_samek, phase_2_diffo_samek)\n\n    return {\n      real: phasor_1_diffo_samek.real + phasor_2_diffo_samek.real,\n      imaginary: phasor_1_diffo_samek.imaginary + phasor_2_diffo_samek.imaginary\n    }\n  }\n)\n\n{\n  const phase_plot = Plot.plot({\n    x: {\n      label: \"Real\",\n      domain: [-4, 4],\n    },\n    y: {\n      label: \"Imaginary\",\n      domain: [-4, 4],\n    },\n    ratio: 1,\n    width: 400,\n    marks: [\n      Plot.ruleY([0], {stroke: \"black\", strokeWidth: 1}),\n      Plot.ruleX([0], {stroke: \"black\", strokeWidth: 1}),\n\n      Plot.line([{real: 0, imaginary: 0}, point_1_diffo_samek], {x: \"real\", y: \"imaginary\", stroke: \"green\", strokeWidth: 2}),\n      Plot.line([{real: 0, imaginary: 0}, point_2_diffo_samek], {x: \"real\", y: \"imaginary\", stroke: \"orange\", strokeWidth: 2}),\n      Plot.line([point_1_diffo_samek, phasor_diffo_samek[0], point_2_diffo_samek], {x: \"real\", y: \"imaginary\", strokeWidth: 2}),\n      Plot.line([{real: 0, imaginary: phasor_diffo_samek[0].imaginary}, phasor_diffo_samek[0]], {x: \"real\", y: \"imaginary\", stroke: \"blue\", strokeWidth: 4}),\n      Plot.dot(phasor_diffo_samek, {x: \"real\", y: \"imaginary\"}),\n\n      Plot.line(phasor_locus_diffo_samek, {x: \"real\", y: \"imaginary\", stroke: \"purple\", strokeWidth: 1}),\n    ],\n  })\n\n  const space_plot = Plot.plot({\n    x: {\n      label: \"Space\",\n      domain: [0, 10],\n    },\n    y: {\n      label: \"Amplitude\",\n      domain: [-4, 4],\n    },\n    ratio: 1,\n    width: 400,\n    marks: [\n      Plot.ruleY([0], {stroke: \"black\", strokeWidth: 1}),\n      Plot.ruleX([0], {stroke: \"black\", strokeWidth: 1}),\n\n      Plot.line([{space: x_diffo_samek, amplitude: 0}, {space: x_diffo_samek, amplitude: phasor_diffo_samek[0].real}],\n        {x: \"space\", y: \"amplitude\", stroke: \"blue\", strokeWidth: 4}),\n      Plot.line(points_space_diffo_samek, {x: \"space\", y: \"amplitude\", stroke: \"red\", strokeWidth: 2}),\n      Plot.dot([{space: x_diffo_samek, amplitude: phasor_diffo_samek[0].real}], {x: \"space\", y: \"amplitude\"}),\n    ],\n  })\n\n  return html`&lt;div style=\"display:flex; gap:20px\"&gt;\n    &lt;h3&gt; Phase Domain\n    ${phase_plot}\n    &lt;h3&gt; Space Domain\n    ${space_plot}\n  &lt;\\div&gt;`\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEssentially what’s happening is that the we are swapping time for space when compared to the previous case. We see a purely sinusoidal wave in the space domain that has a changing amplitude over time. The amplitude is not changing as a pure sinusoid, but rather will be oscillating similar to the space domain plots from the previous case.\n\n\n3.3.4 Case 4: Different Temporal Frequency, Different Spatial Frequency\nThis case is the most general case. It sums together two sinusoids that can have differences in any of their parameters.\n\\[\n\\begin{align*}\ns(t, x) &= M_1 \\cos{(\\omega_1 t - k_1 x + \\phi_1)} + M_2 \\cos{(\\omega_2 t - k_2 x + \\phi_2)} \\\\\n&= \\Re\\left(M_1 e^{i(\\omega_1 t - k_1 x + \\phi_1)} + M_2 e^{i(\\omega_2 t - k_2 x + \\phi_2)}\\right) \\end{align*}\n\\]\n\n\nCode\ntime_duration_diffo_diffk = 10\nspace_dist_diffo_diffk = 10\nspace_array_diffo_diffk = d3.ticks(0, space_dist_diffo_diffk, space_dist_diffo_diffk*fps)\n\nviewof t_diffo_diffk = Scrubber(d3.ticks(0, time_duration_diffo_diffk, time_duration_diffo_diffk*fps), {\n  autoplay: false,\n  loop: true,\n  initial: 0,\n  format: x =&gt; `t [seconds] = ${x.toFixed(2)}`,\n  delay: dt * 1000\n})\nviewof x_diffo_diffk = slider(\n  {\n    min: 0,\n    max: space_dist_diffo_diffk,\n    step: .01,\n    value: 0,\n    label: \"position\",\n    format: v =&gt; \"x [meters]: \" + v.toFixed(2)\n  },\n)\nviewof omega_1_diffo_diffk = slider(\n  {\n    min: .01,\n    max: Math.PI,\n    step: .01,\n    value: 1,\n    label: \"angular frequency\",\n    format: v =&gt; \"ω₁ [radians/second]: \" + v.toFixed(2)\n  },\n)\nviewof k_1_diffo_diffk = slider(\n  {\n    min: -4,\n    max: 4,\n    step: .01,\n    value: 2,\n    label: \"position\",\n    format: v =&gt; \"k₁ [radians/meter]: \" + v.toFixed(2)\n  },\n)\nviewof phase_1_diffo_diffk = slider(\n  {\n    min: -Math.PI,\n    max: Math.PI,\n    step: .01,\n    value: 0.5,\n    label: \"phase shift\",\n    format: v =&gt; \"φ₁ [radians]: \" + v.toFixed(2)\n  },\n)\nviewof magnitude_1_diffo_diffk = slider(\n  {\n    min: 0,\n    max: 2,\n    step: .01,\n    value: 1.4,\n    label: \"magnitude\",\n    format: v =&gt; \"M₁ [magnitude]: \" + v.toFixed(2)\n  },\n)\nviewof omega_2_diffo_diffk = slider(\n  {\n    min: .01,\n    max: Math.PI,\n    step: .01,\n    value: 2,\n    label: \"angular frequency\",\n    format: v =&gt; \"ω₂ [radians/second]: \" + v.toFixed(2)\n  },\n)\nviewof k_2_diffo_diffk = slider(\n  {\n    min: -4,\n    max: 4,\n    step: .01,\n    value: 0.5,\n    label: \"position\",\n    format: v =&gt; \"k₂ [radians/meter]: \" + v.toFixed(2)\n  },\n)\nviewof phase_2_diffo_diffk = slider(\n  {\n    min: -Math.PI,\n    max: Math.PI,\n    step: .01,\n    value: -0.2,\n    label: \"phase shift\",\n    format: v =&gt; \"φ₂ [radians]: \" + v.toFixed(2)\n  },\n)\nviewof magnitude_2_diffo_diffk = slider(\n  {\n    min: 0,\n    max: 2,\n    step: .01,\n    value: 0.8,\n    label: \"magnitude\",\n    format: v =&gt; \"M₂ [magnitude]: \" + v.toFixed(2)\n  },\n)\n\npoints_space_diffo_diffk = Array.from(\n  {length: space_array_diffo_diffk.length}, (_, i) =&gt; {\n    return {\n      space: space_array_diffo_diffk[i],\n      amplitude: calculatePhasor(omega_1_diffo_diffk * t_diffo_diffk, k_1_diffo_diffk * space_array_diffo_diffk[i], magnitude_1_diffo_diffk, phase_1_diffo_diffk).real + \n        calculatePhasor(omega_2_diffo_diffk * t_diffo_diffk, k_2_diffo_diffk * space_array_diffo_diffk[i], magnitude_2_diffo_diffk, phase_2_diffo_diffk).real\n    }\n  }\n)\n\npoint_1_diffo_diffk = calculatePhasor(omega_1_diffo_diffk*t_diffo_diffk, k_1_diffo_diffk * x_diffo_diffk, magnitude_1_diffo_diffk, phase_1_diffo_diffk)\npoint_2_diffo_diffk = calculatePhasor(omega_2_diffo_diffk*t_diffo_diffk, k_2_diffo_diffk * x_diffo_diffk, magnitude_2_diffo_diffk, phase_2_diffo_diffk)\nphasor_diffo_diffk = [\n  {\n    real: point_1_diffo_diffk.real + point_2_diffo_diffk.real,\n    imaginary: point_1_diffo_diffk.imaginary + point_2_diffo_diffk.imaginary\n  }\n]\nphasor_locus_diffo_diffk = Array.from(\n  {length: space_array_diffo_diffk.length}, (_, i) =&gt; {\n    const phasor_1_diffo_diffk = calculatePhasor(omega_1_diffo_diffk * t_diffo_diffk, k_1_diffo_diffk * space_array_diffo_diffk[i], magnitude_1_diffo_diffk, phase_1_diffo_diffk)\n    const phasor_2_diffo_diffk = calculatePhasor(omega_2_diffo_diffk * t_diffo_diffk, k_2_diffo_diffk * space_array_diffo_diffk[i], magnitude_2_diffo_diffk, phase_2_diffo_diffk)\n\n    return {\n      real: phasor_1_diffo_diffk.real + phasor_2_diffo_diffk.real,\n      imaginary: phasor_1_diffo_diffk.imaginary + phasor_2_diffo_diffk.imaginary\n    }\n  }\n)\n\n{\n  const phase_plot = Plot.plot({\n    x: {\n      label: \"Real\",\n      domain: [-4, 4],\n    },\n    y: {\n      label: \"Imaginary\",\n      domain: [-4, 4],\n    },\n    ratio: 1,\n    width: 400,\n    marks: [\n      Plot.ruleY([0], {stroke: \"black\", strokeWidth: 1}),\n      Plot.ruleX([0], {stroke: \"black\", strokeWidth: 1}),\n\n      Plot.line([{real: 0, imaginary: 0}, point_1_diffo_diffk], {x: \"real\", y: \"imaginary\", stroke: \"green\", strokeWidth: 2}),\n      Plot.line([{real: 0, imaginary: 0}, point_2_diffo_diffk], {x: \"real\", y: \"imaginary\", stroke: \"orange\", strokeWidth: 2}),\n      Plot.line([point_1_diffo_diffk, phasor_diffo_diffk[0], point_2_diffo_diffk], {x: \"real\", y: \"imaginary\", strokeWidth: 2}),\n      Plot.line([{real: 0, imaginary: phasor_diffo_diffk[0].imaginary}, phasor_diffo_diffk[0]], {x: \"real\", y: \"imaginary\", stroke: \"blue\", strokeWidth: 4}),\n      Plot.dot(phasor_diffo_diffk, {x: \"real\", y: \"imaginary\"}),\n\n      Plot.line(phasor_locus_diffo_diffk, {x: \"real\", y: \"imaginary\", stroke: \"purple\", strokeWidth: 1}),\n    ],\n  })\n\n  const space_plot = Plot.plot({\n    x: {\n      label: \"Space\",\n      domain: [0, 10],\n    },\n    y: {\n      label: \"Amplitude\",\n      domain: [-4, 4],\n    },\n    ratio: 1,\n    width: 400,\n    marks: [\n      Plot.ruleY([0], {stroke: \"black\", strokeWidth: 1}),\n      Plot.ruleX([0], {stroke: \"black\", strokeWidth: 1}),\n\n      Plot.line([{space: x_diffo_diffk, amplitude: 0}, {space: x_diffo_diffk, amplitude: phasor_diffo_diffk[0].real}],\n        {x: \"space\", y: \"amplitude\", stroke: \"blue\", strokeWidth: 4}),\n      Plot.line(points_space_diffo_diffk, {x: \"space\", y: \"amplitude\", stroke: \"red\", strokeWidth: 2}),\n      Plot.dot([{space: x_diffo_diffk, amplitude: phasor_diffo_diffk[0].real}], {x: \"space\", y: \"amplitude\"}),\n    ],\n  })\n\n  return html`&lt;div style=\"display:flex; gap:20px\"&gt;\n    &lt;h3&gt; Phase Domain\n    ${phase_plot}\n    &lt;h3&gt; Space Domain\n    ${space_plot}\n  &lt;\\div&gt;`\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAt first glance, this looks pretty similar to the case with common temporal frequencies and different spatial frequencies. On closer inspection there are some strange things. For instance, standing waves can now slowly creep through space, oscillating sinusoids can move forwards and then backwards, and in general the locus can now change shape over time.\nThe main effect seems to be that the rotation of the locus can be pushed along further as a result of the different temporal frequencies."
  },
  {
    "objectID": "demos/phasors/phasors.html#conclusion",
    "href": "demos/phasors/phasors.html#conclusion",
    "title": "Phasors",
    "section": "4 Conclusion",
    "text": "4 Conclusion\nHopefully you’re convinced that there is lots of information that can be extracted from signals by looking at its phasor representation. Through this lens, you can extract some intuition about not just sinusoidal signals, but waves, reflections, beats, and more.\nIf you have any questions about particular sections, feel free to highlight them and comment using Hypothesis (sidebar). General comments can be asked in the comments section below."
  },
  {
    "objectID": "demos/phasors/phasors.html#references",
    "href": "demos/phasors/phasors.html#references",
    "title": "Phasors",
    "section": "5 References",
    "text": "5 References\n\nGoldstein, Evan. 2025a. “Input Impedance.” Lecture notes, ECE Department, University of Washington.\n\n\n———. 2025b. “Preliminaries.” Lecture notes, ECE Department, University of Washington."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Alex Choi",
    "section": "",
    "text": "Hi, I’m a PhD student at the University of Washington studying robotics and control. Previously I worked at Amazon as an Applied Scientist, and before that as a Mechanical Engineer. Even further back, I co-founded Longhorn Racing Electric, the Formula SAE Electric team at UT Austin.\nIn my free time I do recreational math, code, play chess, reschedule D&D sessions, and walk my dog (you can see Isaac’s ears in the pic)."
  },
  {
    "objectID": "about.html#education",
    "href": "about.html#education",
    "title": "Alex Choi",
    "section": "Education",
    "text": "Education\nUniversity of Washington | Seattle, WA\nPhD in Electrical and Computer Engineering | Sep 2024 - Present\nUniversity of Texas | Austin, TX\nBS in Mechanical Engineering | Aug 2015 - May 2019"
  },
  {
    "objectID": "about.html#experience",
    "href": "about.html#experience",
    "title": "Alex Choi",
    "section": "Experience",
    "text": "Experience\nAmazon.com | Seattle, WA\nApplied Scientist II | May 2022 - Jun 2024\nAmazon.com | Seattle, WA\nMechanical Engineer II/I | Aug 2019 - May 2022\nSpaceX | Hawthorne, CA\nVehicle Engineering Intern | May 2018 - Aug 2018\nAmazon.com | Seattle, WA\nProduct Design Engineering Intern | May 2017 - Aug 2017"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "blog",
    "section": "",
    "text": "Welcome to my blog! Here are recent posts:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOptimal Group Project Assignment\n\n\n\noptimization\n\n\n\n\n\n\n\n\n\nJul 31, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nA Multidimensional Extension of Buffon’s Needle Problem\n\n\n\nprobability\n\n\n\n\n\n\n\n\n\nNov 17, 2023\n\n\n\n\n\n\n\n\n\n\n\n\nAnimatronic “Henry”\n\n\n\nhardware\n\n\n\n\n\n\n\n\n\nOct 25, 2023\n\n\n\n\n\n\n\n\n\n\n\n\nGenerating 3D Audio with Head Related Transfer Functions (HRTFs)\n\n\n\nsignal processing\n\n\n\n\n\n\n\n\n\nOct 23, 2023\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "hello",
    "section": "",
    "text": "Hi, I’m Alex, you can learn more about me on the about page.\nThis website stores a collection of my personal projects, academic papers, technical demos, or anything else I may have had a part in authoring. Check out the blog for more.\nTo email/contact Alex Choi (me), email contact@alexchoi.me"
  },
  {
    "objectID": "posts/recreational_math/buffon/buffon.html",
    "href": "posts/recreational_math/buffon/buffon.html",
    "title": "A Multidimensional Extension of Buffon’s Needle Problem",
    "section": "",
    "text": "I made a paper on a multidimensional extension of Buffon’s needle problem\nIn my free time I wrote this paper on a multidimensional extension of Buffon’s needle problem. Here it is:\n\nThis browser does not support PDFs. Please download the PDF to view it: &lt;a href=\"buffon_extension.pdf\"&gt;Download PDF&lt;/a&gt;\n\nYou might be asking, “Why did you decide to write a paper on a multidimensional extension of Buffon’s needle problem?”. That’s a good question. If you want to go straight to the technical stuff skip the next section.\nSo it started because I was doing one of the Jane Street puzzles back in August, specifically this one.\nThe way I went about the solution was realizing that this seemed really similar to the Buffon Needle problem which I had heard about through a Numberphile video from way back. I did some modeling on paper and simulation on python and came to a solution by extending the method used for the Buffon Needle in 2D to 3D. Then I got to thinking that someone must have already derived this for all dimensions and I probably could have saved myself a bunch of time by just looking directly for the multidimensional solution. I searched google scholar, arXiv, Wikipedia, but I couldn’t find a generalized solution anywhere. So I figured this would be a good exercise in writing a paper.\n\n1 The Extension\nI’m not going to describe everything in the doc because it’d take too long, but I’ll describe the main points here.\nThe problem statement is as follows. Imagine a space that is tiled by hyperplanes. In 2D this would be regularly spaced horizontal and/or vertical lines, in 3D this would be orthogonal sets of parallel planes, in 4D this would be up to 4 orthogonal sets of parallel 3D volumes, etc. Anything up to an arbitrary D-dimensional space. Now imagine a needle is randomly placed and oriented in that space. Find the probability that the needle crosses more than some number, c, of hyperplanes. To make it trickier, imagine that the needle could be any length, there could be any number of hyperplanes (from N=1 parallel set to N=D parallel sets), and the spacing between the parallel hyperplanes doesn’t have to be the same for every set.\n\nThe strategy is as follows, model the needle using higher dimensional spherical coordinates, then integrate using the necessary conditions for crossing some number of hyperplanes as the bounds of integration.\nThis gets trickier when there are N&gt;1 hyperplane directions. Mainly because now there are many different combinations of hyperplanes that can be crossed to achieve some number of total crossings. In this case we can use the inclusion-exclusion principle to combine the multiple individual probabilities.\nAfter a lot of calculus you end up with expressions for the probability of crossing. You can compare this to simulated versions of the needle as well. Below are the probabilities of having more than some number of crossings for a single hyperplane.\n\nYou can use algebra to then derive the probability of crossing exactly some number of hyperplanes as well.\n\nBelow are the probabilities with multiple hyperplanes. For this problem there doesn’t seem to be a closed-form way to represent the probability with elementary functions if the needle is longer than the hyperplane spacing.\n\nYou can find the scripts I used and the .tex files on my github repo here. As of writing this it’s not fully polished up so fair warning.\n\n\n\n\n\n\n\n\n\n\nEdit History\n\n\n\n\n2025-07-31: Reformatted for new site"
  },
  {
    "objectID": "posts/recreational_math/optimal_groups/optimal_groups.html",
    "href": "posts/recreational_math/optimal_groups/optimal_groups.html",
    "title": "Optimal Group Project Assignment",
    "section": "",
    "text": "My senior design project was essentially randomly assigned.\nThe professor gave us a list of potential projects and told us to group up and rank our top five. When we got our assignments, I was a bit disappointed and confused because I got a project that I did not list on my preferences (something to do with measuring strain using digital image correlation). Stranger still, there had been other people that wanted our project. The professor said that the decisions were final. When asked, he said he ran a monte carlo simulation and picked the one that looked the best. We’re not exactly sure what criteria he used, but the result was that many students were suboptimally assigned.\nYears later, I sometimes think of this, and having TA’d some courses with group projects, I wondered if there was a better way. The following is an approach that uses integer programming.\nSay you have \\(N\\) students and \\(M\\) projects. The goal is to group students to the projects they want in a way that optimizes for some sort of preference. For now, let’s say every student provides a dissatisfaction score \\(d_{n,m} \\in [0, \\infty)\\) for each project. Each student then has a vector \\(d_n \\in \\mathbb R^M\\), and the entire class can be described using the following matrix. \\[\nD = \\begin{bmatrix}\n| & & | \\\\\nd_{1} & \\cdots & d_{N} \\\\\n| & & |\n\\end{bmatrix}\n\\]\nEach student must be assigned to one project. This can be described using a 1-hot vector, \\(a_n\\in\\mathbb R^m\\), where the 1 corresponds to the assigned project. Again, the entire class can be assigned using a matrix. This will act as our decision variable. \\[\nA = \\begin{bmatrix}\n| & & | \\\\\na_{1} & \\cdots & a_{N} \\\\\n| & & |\n\\end{bmatrix}\n\\] We can set maximum and minimum group sizes by specifying that the sum of the rows of \\(A\\) must be between the bounds.\nFor our objective, let’s go with minimizing the total dissatisfaction of the class. This can be notated concisely as \\(\\min_A\\ \\text{Tr}(D^\\intercal A)\\). We can run our optimization as follows.\n\n\nCode\nimport cvxpy as cp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nnp.random.seed(0)\n\nnum_projects = 50\nnum_students = 200\n\nmin_group_size = 3\nmax_group_size = 5\n\ndissatisfaction_matrix = np.random.rand(num_projects, num_students)\nassignment_matrix = cp.Variable((num_projects, num_students), boolean=True)\n\nobjective = cp.Minimize(cp.trace(dissatisfaction_matrix.T @ assignment_matrix))\n\nconstraints = []\nconstraints += [cp.sum(assignment_matrix, axis=0) == 1]  # each student gets assigned to only 1 project\nconstraints += [cp.sum(assignment_matrix, axis=1) &gt;= min_group_size]\nconstraints += [cp.sum(assignment_matrix, axis=1) &lt;= max_group_size]\n\nproblem = cp.Problem(objective, constraints)\nproblem.solve()\n\nstudent_dissatisfaction = np.diag(dissatisfaction_matrix.T @ assignment_matrix.value)\nprint(f\"The most dissatisfaction a student has is {np.max(student_dissatisfaction):.2f}/1.0\")\n\n\nThe most dissatisfaction a student has is 0.11/1.0\n\n\nThat’s pretty good, but this doesn’t yet solve our problem. It’s unreasonable for a student to provide an absolute score for each project. Asking them to pick and rank their top five is much more reasonable. There are many ways you could map a list of five selections to dissatisfaction. One way is to assign constant values to the selections (say, 0 dissatisfaction for your top choice, 0.1 for your second, etc). Then, pick some large value for all omitted projects.\n\n\nCode\nnum_ranks = 5\nomit_cost = 10\n\n# generate rankings from some underlying absolute total ranking\nabsolute_rankings = np.random.rand(num_projects, num_students)\nrankings = np.argsort(absolute_rankings, axis=0)\ntrunc_ranks = rankings[:num_ranks, :]\n\ndissatisfaction_matrix = np.zeros((num_projects, num_students)) + omit_cost\nstudent_vec = np.arange(num_students)\nfor idx, rank in enumerate(trunc_ranks):\n    dissatisfaction_matrix[rank, student_vec] = idx\ndissatisfaction_matrix /= omit_cost # normalize\n\nobjective = cp.Minimize(cp.trace(dissatisfaction_matrix.T @ assignment_matrix))\n\nproblem = cp.Problem(objective, constraints)\nproblem.solve()\n\nstudent_dissatisfaction = np.diag(dissatisfaction_matrix.T @ assignment_matrix.value)\nprint(f\"The most dissatisfaction a student has is {np.max(student_dissatisfaction):.2f}/1.0\")\n\n\nThe most dissatisfaction a student has is 0.20/1.0\n\n\nThis still works. We know that no one was assigned a project they didn’t like because the most dissatisfaction is less than 1. However, maybe we just got lucky. We’re assigning uniformly random preferences for everyone, so it seems likely you’d be able to get everyone something that they like.\nLet’s assume that the popularity of certain projects follows a sort of Zipfian distribution.\n\n\nCode\ndef zipf_pmf(k, N):\n    \"\"\"Return the value of a Zipf probability mass function\"\"\"\n    return 1 / k * 1 / np.sum(1 / np.arange(1, num_projects + 1))\n\nproject_probabilities = zipf_pmf(np.arange(1, num_projects + 1), num_projects)\nfig, ax = plt.subplots()\nax.bar(np.arange(num_projects), project_probabilities)\nax.set_ylabel(\"Probability\")\nax.set_xlabel(\"Project Index\")\n_ = ax.set_title(\"Probability of Picking a Project\")\n\n\n\n\n\n\n\n\n\nWe’ll assume that students populate their preference list by picking from this distribution without replacement.\n\n\nCode\ntrunc_ranks = []\nfor _ in range(num_students):\n    trunc_ranks.append(np.random.choice(np.arange(num_projects), 5, replace=False, p=project_probabilities))\n\ntrunc_ranks = np.asarray(trunc_ranks).T\n\n\nNow we can solve as before.\n\n\nCode\ndissatisfaction_matrix = np.zeros((num_projects, num_students)) + omit_cost\nstudent_vec = np.arange(num_students)\nfor idx, rank in enumerate(trunc_ranks):\n    dissatisfaction_matrix[rank, student_vec] = idx\ndissatisfaction_matrix /= omit_cost # normalize\n\nobjective = cp.Minimize(cp.trace(dissatisfaction_matrix.T @ assignment_matrix))\n\nproblem = cp.Problem(objective, constraints)\nproblem.solve()\n\nstudent_dissatisfaction = np.diag(dissatisfaction_matrix.T @ assignment_matrix.value)\nprint(f\"The most dissatisfaction a student has is {np.max(student_dissatisfaction):.2f}/1.0\")\n\n\nThe most dissatisfaction a student has is 0.40/1.0\n\n\nAs expected, the worst case dissatisfaction did go up. But, you know what I can’t get over?\n\n\nCode\nprint(f\"Number of students that didn't get anything on their list: {np.sum(student_dissatisfaction == 1)}.\")\n\n\nNumber of students that didn't get anything on their list: 0."
  }
]